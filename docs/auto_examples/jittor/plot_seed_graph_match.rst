
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples\jittor\plot_seed_graph_match.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_examples_jittor_plot_seed_graph_match.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_jittor_plot_seed_graph_match.py:


======================
Seeded Graph Matching
======================

Seeded graph matching means some partial of the matching result is already known, and the known matching
results are called "seeds". In this example, we show how to exploit such prior with ``pygmtools``.

.. GENERATED FROM PYTHON SOURCE LINES 10-16

.. code-block:: default


    # Author: Runzhong Wang <runzhong.wang@sjtu.edu.cn>
    #         Qi Liu <purewhite@sjtu.edu.cn>
    #
    # License: Mulan PSL v2 License








.. GENERATED FROM PYTHON SOURCE LINES 18-33

.. note::
    How to perform seeded graph matching is still an open research problem. In this example, we show a
    simple yet effective approach that works with ``pygmtools``.

.. note::
    The following solvers are included in this example:

    * :func:`~pygmtools.classic_solvers.rrwm` (classic solver)

    * :func:`~pygmtools.classic_solvers.ipfp` (classic solver)

    * :func:`~pygmtools.classic_solvers.sm` (classic solver)

    * :func:`~pygmtools.neural_solvers.ngm` (neural network solver)


.. GENERATED FROM PYTHON SOURCE LINES 33-62

.. code-block:: default

    import jittor as jt # jittor backend
    import pygmtools as pygm
    import matplotlib.pyplot as plt # for plotting
    from matplotlib.patches import ConnectionPatch # for plotting matching result
    import networkx as nx # for plotting graphs
    pygm.BACKEND = 'jittor' # set default backend for pygmtools
    _ = jt.set_seed(1) # fix random seed

    # jt.flags.use_cuda = 1 # use cuda


    #! The following code is used for testing jittor codes.
    import numpy as np

    def namestr(obj):
     return [name for name in globals() if globals()[name] is obj][0]

    def load_var(*args):
        ret = []
        for var in args:
            ret.append(jt.Var(np.load(f'../{namestr(var)}.npy')))
        return ret
        

    def compare_var(*args):
        for var in args:
            var_np = np.load(f'../{namestr(var)}.npy')
            assert np.allclose(var.numpy(), var_np, rtol=1e-4)








.. GENERATED FROM PYTHON SOURCE LINES 63-68

Generate two isomorphic graphs (with seeds)
-------------------------------------------
In this example, we assume the first three nodes are already aligned. Firstly, we generate the seed matching
matrix:


.. GENERATED FROM PYTHON SOURCE LINES 68-73

.. code-block:: default

    num_nodes = 10
    num_seeds = 3
    seed_mat = jt.zeros((num_nodes, num_nodes))
    seed_mat[:num_seeds, :num_seeds] = jt.init.eye(num_seeds)








.. GENERATED FROM PYTHON SOURCE LINES 74-76

Then we generate the isomorphic graphs:


.. GENERATED FROM PYTHON SOURCE LINES 76-89

.. code-block:: default

    X_gt = seed_mat.clone()

    #! X_gt[num_seeds:, num_seeds:][jt.arange(0, num_nodes-num_seeds, dtype=jt.int64), jt.randperm(num_nodes-num_seeds)] = 1 doesn't work.
    X_gt[jt.arange(num_seeds, num_nodes), jt.arange(num_seeds, num_nodes)[jt.randperm(num_nodes-num_seeds)]] = 1
    A1 = jt.rand(num_nodes, num_nodes)
    A1 = (A1 + A1.t() > 1.) * (A1 + A1.t()) / 2

    #! jt.diag(A1)[:] = 0 doesn't work.
    A1[jt.arange(A1.shape[0]), jt.arange(A1.shape[0])] = 0
    A2 = jt.matmul(jt.matmul(X_gt.t(), A1), X_gt)
    n1 = jt.Var([num_nodes])
    n2 = jt.Var([num_nodes])








.. GENERATED FROM PYTHON SOURCE LINES 90-94

Visualize the graphs and seeds
-------------------------------
The seed matching matrix:


.. GENERATED FROM PYTHON SOURCE LINES 94-98

.. code-block:: default

    plt.figure(figsize=(4, 4))
    plt.title('Seed Matching Matrix')
    plt.imshow(seed_mat.numpy(), cmap='Blues')




.. image-sg:: /auto_examples/jittor/images/sphx_glr_plot_seed_graph_match_001.png
   :alt: Seed Matching Matrix
   :srcset: /auto_examples/jittor/images/sphx_glr_plot_seed_graph_match_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <matplotlib.image.AxesImage object at 0x000001F03E603E80>



.. GENERATED FROM PYTHON SOURCE LINES 99-101

The blue lines denote the matching seeds.


.. GENERATED FROM PYTHON SOURCE LINES 101-118

.. code-block:: default

    plt.figure(figsize=(8, 4))
    G1 = nx.from_numpy_array(A1.numpy())
    G2 = nx.from_numpy_array(A2.numpy())
    pos1 = nx.spring_layout(G1)
    pos2 = nx.spring_layout(G2)
    ax1 = plt.subplot(1, 2, 1)
    plt.title('Graph 1')
    nx.draw_networkx(G1, pos=pos1)
    ax2 = plt.subplot(1, 2, 2)
    plt.title('Graph 2')
    nx.draw_networkx(G2, pos=pos2)
    for i in range(num_seeds):
        j = jt.argmax(seed_mat[i], dim=-1)[0].item()
        con = ConnectionPatch(xyA=pos1[i], xyB=pos2[j], coordsA="data", coordsB="data",
                              axesA=ax1, axesB=ax2, color="blue")
        plt.gca().add_artist(con)




.. image-sg:: /auto_examples/jittor/images/sphx_glr_plot_seed_graph_match_002.png
   :alt: Graph 1, Graph 2
   :srcset: /auto_examples/jittor/images/sphx_glr_plot_seed_graph_match_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 119-134

Now these two graphs look dissimilar because they are not aligned. We then align these two graphs
by graph matching.

Build affinity matrix with seed prior
--------------------------------------
We follow the formulation of Quadratic Assignment Problem (QAP):

.. math::

    &\max_{\mathbf{X}} \ \texttt{vec}(\mathbf{X})^\top \mathbf{K} \texttt{vec}(\mathbf{X})\\
    s.t. \quad &\mathbf{X} \in \{0, 1\}^{n_1\times n_2}, \ \mathbf{X}\mathbf{1} = \mathbf{1}, \ \mathbf{X}^\top\mathbf{1} \leq \mathbf{1}

where the first step is to build the affinity matrix (:math:`\mathbf{K}`). We firstly build a "standard"
affinity matrix:


.. GENERATED FROM PYTHON SOURCE LINES 134-140

.. code-block:: default

    conn1, edge1 = pygm.utils.dense_to_sparse(A1)
    conn2, edge2 = pygm.utils.dense_to_sparse(A2)
    import functools
    gaussian_aff = functools.partial(pygm.utils.gaussian_aff_fn, sigma=.1) # set affinity function
    K = pygm.utils.build_aff_mat(None, edge1, conn1, None, edge2, conn2, n1, None, n2, None, edge_aff_fn=gaussian_aff)








.. GENERATED FROM PYTHON SOURCE LINES 141-150

The next step is to add the seed matching information as priors to the affinity matrix. The matching priors
are treated as node affinities and the corresponding node affinity is added by 10 if there is an matching
prior.

.. note::
    The node affinity matrix is transposed because in the graph matching formulation followed by ``pygmtools``,
    :math:`\texttt{vec}(\mathbf{X})` means column vectorization. The node affinity should also be column-
    vectorized.


.. GENERATED FROM PYTHON SOURCE LINES 150-152

.. code-block:: default

    K += jt.diag(seed_mat.t().reshape(-1) * 10)








.. GENERATED FROM PYTHON SOURCE LINES 153-158

Visualization of the affinity matrix.

.. note::
    In this example, the diagonal elements reflect the matching prior.


.. GENERATED FROM PYTHON SOURCE LINES 158-162

.. code-block:: default

    plt.figure(figsize=(4, 4))
    plt.title(f'Affinity Matrix (size: {K.shape[0]}$\\times${K.shape[1]})')
    plt.imshow(K.numpy(), cmap='Blues')




.. image-sg:: /auto_examples/jittor/images/sphx_glr_plot_seed_graph_match_003.png
   :alt: Affinity Matrix (size: 100$\times$100)
   :srcset: /auto_examples/jittor/images/sphx_glr_plot_seed_graph_match_003.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <matplotlib.image.AxesImage object at 0x000001F03D1CF550>



.. GENERATED FROM PYTHON SOURCE LINES 163-167

Solve graph matching problem by RRWM solver
-------------------------------------------
See :func:`~pygmtools.classic_solvers.rrwm` for the API reference.


.. GENERATED FROM PYTHON SOURCE LINES 167-169

.. code-block:: default

    X = pygm.rrwm(K, n1, n2)








.. GENERATED FROM PYTHON SOURCE LINES 170-172

The output of RRWM is a soft matching matrix. The matching prior is well-preserved:


.. GENERATED FROM PYTHON SOURCE LINES 172-180

.. code-block:: default

    plt.figure(figsize=(8, 4))
    plt.subplot(1, 2, 1)
    plt.title('RRWM Soft Matching Matrix')
    plt.imshow(X.numpy(), cmap='Blues')
    plt.subplot(1, 2, 2)
    plt.title('Ground Truth Matching Matrix')
    plt.imshow(X_gt.numpy(), cmap='Blues')




.. image-sg:: /auto_examples/jittor/images/sphx_glr_plot_seed_graph_match_004.png
   :alt: RRWM Soft Matching Matrix, Ground Truth Matching Matrix
   :srcset: /auto_examples/jittor/images/sphx_glr_plot_seed_graph_match_004.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <matplotlib.image.AxesImage object at 0x000001F03D12A340>



.. GENERATED FROM PYTHON SOURCE LINES 181-185

Get the discrete matching matrix
---------------------------------
Hungarian algorithm is then adopted to reach a discrete matching matrix


.. GENERATED FROM PYTHON SOURCE LINES 185-187

.. code-block:: default

    X = pygm.hungarian(X)








.. GENERATED FROM PYTHON SOURCE LINES 188-190

Visualization of the discrete matching matrix:


.. GENERATED FROM PYTHON SOURCE LINES 190-198

.. code-block:: default

    plt.figure(figsize=(8, 4))
    plt.subplot(1, 2, 1)
    plt.title(f'RRWM Matching Matrix (acc={(X * X_gt).sum()/ X_gt.sum():.2f})')
    plt.imshow(X.numpy(), cmap='Blues')
    plt.subplot(1, 2, 2)
    plt.title('Ground Truth Matching Matrix')
    plt.imshow(X_gt.numpy(), cmap='Blues')




.. image-sg:: /auto_examples/jittor/images/sphx_glr_plot_seed_graph_match_005.png
   :alt: RRWM Matching Matrix (acc=1.00), Ground Truth Matching Matrix
   :srcset: /auto_examples/jittor/images/sphx_glr_plot_seed_graph_match_005.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <matplotlib.image.AxesImage object at 0x000001F03E2866A0>



.. GENERATED FROM PYTHON SOURCE LINES 199-204

Align the original graphs
--------------------------
Draw the matching (green lines for correct matching, red lines for wrong matching, blue lines for
seed matching):


.. GENERATED FROM PYTHON SOURCE LINES 204-223

.. code-block:: default

    plt.figure(figsize=(8, 4))
    ax1 = plt.subplot(1, 2, 1)
    plt.title('Graph 1')
    nx.draw_networkx(G1, pos=pos1)
    ax2 = plt.subplot(1, 2, 2)
    plt.title('Graph 2')
    nx.draw_networkx(G2, pos=pos2)
    for i in range(num_nodes):
        j = jt.argmax(X[i], dim=-1)[0].item()
        if seed_mat[i, j] == 1:
            line_color = "blue"
        elif X_gt[i, j] == 1:
            line_color = "green"
        else:
            line_color = "red"
        con = ConnectionPatch(xyA=pos1[i], xyB=pos2[j], coordsA="data", coordsB="data",
                              axesA=ax1, axesB=ax2, color=line_color)
        plt.gca().add_artist(con)




.. image-sg:: /auto_examples/jittor/images/sphx_glr_plot_seed_graph_match_006.png
   :alt: Graph 1, Graph 2
   :srcset: /auto_examples/jittor/images/sphx_glr_plot_seed_graph_match_006.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 224-226

Align the nodes:


.. GENERATED FROM PYTHON SOURCE LINES 226-248

.. code-block:: default

    align_A2 = jt.matmul(jt.matmul(X, A2), X.t())
    plt.figure(figsize=(8, 4))
    ax1 = plt.subplot(1, 2, 1)
    plt.title('Graph 1')
    nx.draw_networkx(G1, pos=pos1)
    ax2 = plt.subplot(1, 2, 2)
    plt.title('Aligned Graph 2')
    align_pos2 = {}
    for i in range(num_nodes):
        j = jt.argmax(X[i], dim=-1)[0].item()
        align_pos2[j] = pos1[i]
        if seed_mat[i, j] == 1:
            line_color = "blue"
        elif X_gt[i, j] == 1:
            line_color = "green"
        else:
            line_color = "red"
        con = ConnectionPatch(xyA=pos1[i], xyB=align_pos2[j], coordsA="data", coordsB="data",
                              axesA=ax1, axesB=ax2, color=line_color)
        plt.gca().add_artist(con)
    nx.draw_networkx(G2, pos=align_pos2)




.. image-sg:: /auto_examples/jittor/images/sphx_glr_plot_seed_graph_match_007.png
   :alt: Graph 1, Aligned Graph 2
   :srcset: /auto_examples/jittor/images/sphx_glr_plot_seed_graph_match_007.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 249-258

Other solvers are also available
---------------------------------
Only the affinity matrix is modified to encode matching priors, thus other graph matching solvers are also
available to handle this seeded graph matching setting.

Classic IPFP solver
^^^^^^^^^^^^^^^^^^^^^
See :func:`~pygmtools.classic_solvers.ipfp` for the API reference.


.. GENERATED FROM PYTHON SOURCE LINES 258-260

.. code-block:: default

    X = pygm.ipfp(K, n1, n2)








.. GENERATED FROM PYTHON SOURCE LINES 261-263

Visualization of IPFP matching result:


.. GENERATED FROM PYTHON SOURCE LINES 263-271

.. code-block:: default

    plt.figure(figsize=(8, 4))
    plt.subplot(1, 2, 1)
    plt.title(f'IPFP Matching Matrix (acc={(X * X_gt).sum()/ X_gt.sum():.2f})')
    plt.imshow(X.numpy(), cmap='Blues')
    plt.subplot(1, 2, 2)
    plt.title('Ground Truth Matching Matrix')
    plt.imshow(X_gt.numpy(), cmap='Blues')




.. image-sg:: /auto_examples/jittor/images/sphx_glr_plot_seed_graph_match_008.png
   :alt: IPFP Matching Matrix (acc=1.00), Ground Truth Matching Matrix
   :srcset: /auto_examples/jittor/images/sphx_glr_plot_seed_graph_match_008.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <matplotlib.image.AxesImage object at 0x000001F03E579D60>



.. GENERATED FROM PYTHON SOURCE LINES 272-276

Classic SM solver
^^^^^^^^^^^^^^^^^^^^^
See :func:`~pygmtools.classic_solvers.sm` for the API reference.


.. GENERATED FROM PYTHON SOURCE LINES 276-279

.. code-block:: default

    X = pygm.sm(K, n1, n2)
    X = pygm.hungarian(X)








.. GENERATED FROM PYTHON SOURCE LINES 280-282

Visualization of SM matching result:


.. GENERATED FROM PYTHON SOURCE LINES 282-290

.. code-block:: default

    plt.figure(figsize=(8, 4))
    plt.subplot(1, 2, 1)
    plt.title(f'SM Matching Matrix (acc={(X * X_gt).sum()/ X_gt.sum():.2f})')
    plt.imshow(X.numpy(), cmap='Blues')
    plt.subplot(1, 2, 2)
    plt.title('Ground Truth Matching Matrix')
    plt.imshow(X_gt.numpy(), cmap='Blues')




.. image-sg:: /auto_examples/jittor/images/sphx_glr_plot_seed_graph_match_009.png
   :alt: SM Matching Matrix (acc=1.00), Ground Truth Matching Matrix
   :srcset: /auto_examples/jittor/images/sphx_glr_plot_seed_graph_match_009.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <matplotlib.image.AxesImage object at 0x000001F03EBB0A60>



.. GENERATED FROM PYTHON SOURCE LINES 291-295

NGM neural network solver
^^^^^^^^^^^^^^^^^^^^^^^^^
See :func:`~pygmtools.neural_solvers.ngm` for the API reference.


.. GENERATED FROM PYTHON SOURCE LINES 295-299

.. code-block:: default

    with jt.no_grad():
        X = pygm.ngm(K, n1, n2, pretrain='voc')
        X = pygm.hungarian(X)








.. GENERATED FROM PYTHON SOURCE LINES 300-302

Visualization of NGM matching result:


.. GENERATED FROM PYTHON SOURCE LINES 302-308

.. code-block:: default

    plt.figure(figsize=(8, 4))
    plt.subplot(1, 2, 1)
    plt.title(f'NGM Matching Matrix (acc={(X * X_gt).sum()/ X_gt.sum():.2f})')
    plt.imshow(X.numpy(), cmap='Blues')
    plt.subplot(1, 2, 2)
    plt.title('Ground Truth Matching Matrix')
    plt.imshow(X_gt.numpy(), cmap='Blues')


.. image-sg:: /auto_examples/jittor/images/sphx_glr_plot_seed_graph_match_010.png
   :alt: NGM Matching Matrix (acc=1.00), Ground Truth Matching Matrix
   :srcset: /auto_examples/jittor/images/sphx_glr_plot_seed_graph_match_010.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <matplotlib.image.AxesImage object at 0x000001F03EDC0100>




.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  1.246 seconds)


.. _sphx_glr_download_auto_examples_jittor_plot_seed_graph_match.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_seed_graph_match.py <plot_seed_graph_match.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_seed_graph_match.ipynb <plot_seed_graph_match.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
